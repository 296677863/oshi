<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>PerfCounterQuery.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">oshi-dist</a> &gt; <a href="../index.html" class="el_bundle">oshi-core</a> &gt; <a href="index.source.html" class="el_package">oshi.util.platform.windows</a> &gt; <span class="el_source">PerfCounterQuery.java</span></div><h1>PerfCounterQuery.java</h1><pre class="source lang-java linenums">/**
 * MIT License
 *
 * Copyright (c) 2010 - 2020 The OSHI Project Contributors: https://github.com/oshi/oshi/graphs/contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package oshi.util.platform.windows;

import java.util.EnumMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.jna.platform.win32.COM.Wbemcli; //NOSONAR
import com.sun.jna.platform.win32.COM.WbemcliUtil.WmiQuery;
import com.sun.jna.platform.win32.COM.WbemcliUtil.WmiResult;

import oshi.annotation.concurrent.NotThreadSafe;
import oshi.util.platform.windows.PerfDataUtil.PerfCounter;

/**
 * Encapsulates information for a Performance Counter query.
 * &lt;p&gt;
 * An instance of this class should only be instantiated and used within the
 * context of a single thread.
 */
@NotThreadSafe
public class PerfCounterQuery&lt;T extends Enum&lt;T&gt;&gt; {

<span class="nc" id="L48">    private static final Logger LOG = LoggerFactory.getLogger(PerfCounterQuery.class);</span>

    /*
     * Set on instantiation
     */
    protected final Class&lt;T&gt; propertyEnum;
    protected final String perfObject;
    protected final String perfWmiClass;
    protected final String queryKey;
    protected CounterDataSource source;
    protected PerfCounterQueryHandler pdhQueryHandler;

    /*
     * Only one will be non-null depending on source
     */
<span class="nc" id="L63">    private EnumMap&lt;T, PerfCounter&gt; counterMap = null;</span>
<span class="nc" id="L64">    protected WmiQuery&lt;T&gt; counterQuery = null;</span>

    /*
     * Multiple classes use these constants
     */
    /** Constant &lt;code&gt;TOTAL_INSTANCE=&quot;_Total&quot;&lt;/code&gt; */
    public static final String TOTAL_INSTANCE = &quot;_Total&quot;;
    /** Constant &lt;code&gt;TOTAL_INSTANCES=&quot;*_Total&quot;&lt;/code&gt; */
    public static final String TOTAL_INSTANCES = &quot;*_Total&quot;;
    /** Constant &lt;code&gt;NOT_TOTAL_INSTANCE=&quot;^ + TOTAL_INSTANCE&quot;&lt;/code&gt; */
    public static final String NOT_TOTAL_INSTANCE = &quot;^&quot; + TOTAL_INSTANCE;
    /** Constant &lt;code&gt;NOT_TOTAL_INSTANCES=&quot;^ + TOTAL_INSTANCES&quot;&lt;/code&gt; */
    public static final String NOT_TOTAL_INSTANCES = &quot;^&quot; + TOTAL_INSTANCES;

    /**
     * Construct a new object to hold performance counter data source and results
     *
     * @param propertyEnum
     *            An enum which implements
     *            {@link oshi.util.platform.windows.PerfCounterQuery.PdhCounterProperty}
     *            and contains the WMI field (Enum value) and PDH Counter string
     *            (instance and counter)
     * @param perfObject
     *            The PDH object for this counter; all counters on this object will
     *            be refreshed at the same time
     * @param perfWmiClass
     *            The WMI PerfData_RawData_* class corresponding to the PDH object
     */
    public PerfCounterQuery(Class&lt;T&gt; propertyEnum, String perfObject, String perfWmiClass) {
<span class="nc" id="L93">        this(propertyEnum, perfObject, perfWmiClass, perfObject);</span>
<span class="nc" id="L94">    }</span>

    /**
     * Construct a new object to hold performance counter data source and results
     *
     * @param propertyEnum
     *            An enum which implements
     *            {@link oshi.util.platform.windows.PerfCounterQuery.PdhCounterProperty}
     *            and contains the WMI field (Enum value) and PDH Counter string
     *            (instance and counter)
     * @param perfObject
     *            The PDH object for this counter; all counters on this object will
     *            be refreshed at the same time
     * @param perfWmiClass
     *            The WMI PerfData_RawData_* class corresponding to the PDH object
     * @param queryKey
     *            An optional key for PDH counter updates; defaults to the PDH
     *            object name
     */
<span class="nc" id="L113">    public PerfCounterQuery(Class&lt;T&gt; propertyEnum, String perfObject, String perfWmiClass, String queryKey) {</span>
<span class="nc" id="L114">        this.propertyEnum = propertyEnum;</span>
<span class="nc" id="L115">        this.perfObject = perfObject;</span>
<span class="nc" id="L116">        this.perfWmiClass = perfWmiClass;</span>
<span class="nc" id="L117">        this.queryKey = queryKey;</span>
<span class="nc" id="L118">        this.pdhQueryHandler = new PerfCounterQueryHandler();</span>
        // Start off with PDH as source; if query here fails we will permanently
        // fall back to WMI
<span class="nc" id="L121">        this.source = CounterDataSource.PDH;</span>
<span class="nc" id="L122">    }</span>

    /**
     * Set the Data Source for these counters
     *
     * @param source
     *            The source of data
     * @return Whether the data source was successfully set
     */
    public boolean setDataSource(CounterDataSource source) {
<span class="nc" id="L132">        this.source = source;</span>
<span class="nc bnc" id="L133" title="All 3 branches missed.">        switch (source) {</span>
        case PDH:
<span class="nc" id="L135">            LOG.debug(&quot;Attempting to set PDH Data Source.&quot;);</span>
<span class="nc" id="L136">            unInitWmiCounters();</span>
<span class="nc" id="L137">            return initPdhCounters();</span>
        case WMI:
<span class="nc" id="L139">            LOG.debug(&quot;Attempting to set WMI Data Source.&quot;);</span>
<span class="nc" id="L140">            unInitPdhCounters();</span>
<span class="nc" id="L141">            initWmiCounters();</span>
<span class="nc" id="L142">            return true;</span>
        default:
            // This should never happen unless you've added a new source and
            // forgot to add a case for it
<span class="nc" id="L146">            throw new IllegalArgumentException(&quot;Invalid Data Source specified.&quot;);</span>
        }
    }

    /**
     * Initialize PDH counters for this data source. Adds necessary counters to a
     * PDH Query.
     *
     * @return True if the counters were successfully added.
     */
    protected boolean initPdhCounters() {
<span class="nc" id="L157">        this.counterMap = new EnumMap&lt;&gt;(propertyEnum);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">        for (T prop : propertyEnum.getEnumConstants()) {</span>
<span class="nc" id="L159">            PerfCounter counter = PerfDataUtil.createCounter(perfObject, ((PdhCounterProperty) prop).getInstance(),</span>
<span class="nc" id="L160">                    ((PdhCounterProperty) prop).getCounter());</span>
<span class="nc" id="L161">            counterMap.put(prop, counter);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            if (!pdhQueryHandler.addCounterToQuery(counter, this.queryKey)) {</span>
<span class="nc" id="L163">                unInitPdhCounters();</span>
<span class="nc" id="L164">                return false;</span>
            }
        }
<span class="nc" id="L167">        return true;</span>
    }

    /**
     * Uninitialize PDH counters for this data source. Removes necessary counters
     * from the PDH Query, releasing their handles.
     */
    protected void unInitPdhCounters() {
<span class="nc" id="L175">        pdhQueryHandler.removeAllCountersFromQuery(this.queryKey);</span>
<span class="nc" id="L176">        this.counterMap = null;</span>
<span class="nc" id="L177">    }</span>

    /**
     * Initialize the WMI query object needed to retrieve counters for this data
     * source.
     */
    protected void initWmiCounters() {
<span class="nc" id="L184">        this.counterQuery = new WmiQuery&lt;&gt;(perfWmiClass, propertyEnum);</span>
<span class="nc" id="L185">    }</span>

    /**
     * Uninitializes the WMI query object needed to retrieve counters for this data
     * source, allowing it to be garbage collected.
     */
    protected void unInitWmiCounters() {
<span class="nc" id="L192">        this.counterQuery = null;</span>
<span class="nc" id="L193">    }</span>

    /**
     * Query the current data source (PDH or WMI) for the Performance Counter values
     * corresponding to the property enum.
     *
     * @return A map of the values by the counter enum.
     */
    public Map&lt;T, Long&gt; queryValues() {
<span class="nc" id="L202">        EnumMap&lt;T, Long&gt; valueMap = new EnumMap&lt;&gt;(propertyEnum);</span>
<span class="nc" id="L203">        T[] props = this.propertyEnum.getEnumConstants();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        if (source.equals(CounterDataSource.PDH)) {</span>
            // Set up the query and counter handles, and query
<span class="nc bnc" id="L206" title="All 4 branches missed.">            if (initPdhCounters() &amp;&amp; queryPdh(valueMap, props)) {</span>
                // If both init and query return true, then valueMap contains
                // the results. Release the handles.
<span class="nc" id="L209">                unInitPdhCounters();</span>
            } else {
                // If either init or query failed, switch to WMI
<span class="nc" id="L212">                setDataSource(CounterDataSource.WMI);</span>
            }
        }
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (source.equals(CounterDataSource.WMI)) {</span>
<span class="nc" id="L216">            queryWmi(valueMap, props);</span>
        }
<span class="nc" id="L218">        return valueMap;</span>
    }

    private boolean queryPdh(Map&lt;T, Long&gt; valueMap, T[] props) {
<span class="nc bnc" id="L222" title="All 4 branches missed.">        if (counterMap != null &amp;&amp; 0 &lt; pdhQueryHandler.updateQuery(this.queryKey)) {</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">            for (T prop : props) {</span>
<span class="nc" id="L224">                valueMap.put(prop, pdhQueryHandler.queryCounter(counterMap.get(prop)));</span>
            }
<span class="nc" id="L226">            return true;</span>
        }
        // Zero timestamp means update failed after muliple
        // attempts; fallback to WMI
<span class="nc" id="L230">        return false;</span>
    }

    private void queryWmi(Map&lt;T, Long&gt; valueMap, T[] props) {
<span class="nc" id="L234">        WmiResult&lt;T&gt; result = WmiQueryHandler.createInstance().queryWMI(this.counterQuery);</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">        if (result.getResultCount() &gt; 0) {</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">            for (T prop : props) {</span>
<span class="nc bnc" id="L237" title="All 4 branches missed.">                switch (result.getCIMType(prop)) {</span>
                case Wbemcli.CIM_UINT16:
<span class="nc" id="L239">                    valueMap.put(prop, Long.valueOf(WmiUtil.getUint16(result, prop, 0)));</span>
<span class="nc" id="L240">                    break;</span>
                case Wbemcli.CIM_UINT32:
<span class="nc" id="L242">                    valueMap.put(prop, WmiUtil.getUint32asLong(result, prop, 0));</span>
<span class="nc" id="L243">                    break;</span>
                case Wbemcli.CIM_UINT64:
<span class="nc" id="L245">                    valueMap.put(prop, WmiUtil.getUint64(result, prop, 0));</span>
<span class="nc" id="L246">                    break;</span>
                default:
<span class="nc" id="L248">                    throw new ClassCastException(&quot;Unimplemented CIM Type Mapping.&quot;);</span>
                }
            }
        }
<span class="nc" id="L252">    }</span>

    /**
     * Source of performance counter data.
     */
<span class="nc" id="L257">    public enum CounterDataSource {</span>
        /**
         * Performance Counter data will be pulled from a PDH Counter
         */
<span class="nc" id="L261">        PDH,</span>
        /**
         * Performance Counter data will be pulled from a WMI PerfData_RawData_* table
         */
<span class="nc" id="L265">        WMI;</span>
    }

    /**
     * Contract for Counter Property Enums
     */
    public interface PdhCounterProperty {
        /**
         * @return Returns the instance.
         */
        String getInstance();

        /**
         * @return Returns the counter.
         */
        String getCounter();
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>